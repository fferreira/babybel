(* Initial idea for the syntax of megapteraML *)

let _ = {def|

tp: type.
nat : tp.
arr : tp -> tp -> tp.

tm : type.
z : tm.
s : tm -> tm.
cas : tm -> tm -> (tm -> tm) -> tm.
app : tm -> tm -> tm.
lam : (tm -> tm) -> tm.
fix : (tm -> tm) -> tm.

schema ctx = tm;

|def}

(* some options for the pattern matching syntax *)

(* equational style *)
let eval = {fun|
eval : [g |- tp] -> [h |- tp]
eval [g |- z] = [g |- z]
eval [g|- app (lam (\x. 'm)) 'n] = eval [g |- m' 'n]
|fun}

(* explicit pattern matching *)
let rec eval e =
  {match| e with
   | [g |- z] -> [g |- z]
   | [g|- app (lam (\x. 'm)) 'n] -> eval [g |- m' 'n]
   |match}

(* minimal embedding *)

let rec eval e =
  match e with
  | {| g |- z |} -> {| g |- z |}
  | {| g|- app (lam (\x. 'm)) 'n |} -> eval {|g |- m' 'n|}

let res = eval {| app (lam (\x. x)) z |}
